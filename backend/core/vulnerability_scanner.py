"""
VULNERABILITY SCANNER - Advanced Security Assessment Module
Automated vulnerability scanning and assessment engine
"""

import asyncio
import json
import uuid
import subprocess
from typing import Dict, List, Optional, AsyncGenerator
from datetime import datetime, timedelta
from dataclasses import dataclass
from enum import Enum
try:
    import nmap
    NMAP_AVAILABLE = True
except ImportError:
    NMAP_AVAILABLE = False
import socket
import requests
from utils.logger import setup_logger

logger = setup_logger(__name__)

class ScanType(Enum):
    BASIC = "basic"
    COMPREHENSIVE = "comprehensive"
    STEALTH = "stealth"
    AGGRESSIVE = "aggressive"
    CUSTOM = "custom"

class SeverityLevel(Enum):
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"

@dataclass
class Vulnerability:
    id: str
    name: str
    description: str
    severity: SeverityLevel
    cvss_score: float
    cve_id: Optional[str]
    affected_service: str
    port: int
    solution: str
    references: List[str]
    discovered_at: datetime

@dataclass
class ScanResult:
    scan_id: str
    target: str
    scan_type: ScanType
    status: str
    progress: int
    vulnerabilities: List[Vulnerability]
    start_time: datetime
    end_time: Optional[datetime]
    duration: Optional[float]

class VulnerabilityScanner:
    def __init__(self):
        self.active_scans: Dict[str, ScanResult] = {}
        self.scan_history: List[ScanResult] = []
        if NMAP_AVAILABLE:
            try:
                self.nm = nmap.PortScanner()
                logger.info("Nmap integration enabled")
            except:
                self.nm = None
                logger.warning("Nmap not available, using basic port scanning")
        else:
            self.nm = None
            logger.warning("Nmap module not installed, using basic port scanning")
        self._running = False
        self._continuous_scan_task = None
        
        logger.info("Vulnerability Scanner initialized")

    def is_ready(self) -> bool:
        """Check if scanner is ready"""
        return True

    async def start_scan(self, target: str, scan_type: str = "basic") -> str:
        """Start a vulnerability scan"""
        scan_id = str(uuid.uuid4())
        scan_type_enum = ScanType(scan_type)
        
        # Create scan result
        scan_result = ScanResult(
            scan_id=scan_id,
            target=target,
            scan_type=scan_type_enum,
            status="running",
            progress=0,
            vulnerabilities=[],
            start_time=datetime.now(),
            end_time=None,
            duration=None
        )
        
        self.active_scans[scan_id] = scan_result
        
        # Start scan in background
        asyncio.create_task(self._execute_scan(scan_id))
        
        logger.info(f"🎯 Started {scan_type} scan for {target} (ID: {scan_id})")
        return scan_id

    async def _execute_scan(self, scan_id: str):
        """Execute the actual vulnerability scan"""
        scan_result = self.active_scans[scan_id]
        
        try:
            # Phase 1: Port Discovery
            scan_result.progress = 10
            logger.info(f"🔍 Phase 1: Port discovery for {scan_result.target}")
            open_ports = await self._discover_ports(scan_result.target)
            
            # Phase 2: Service Detection
            scan_result.progress = 30
            logger.info(f"🔍 Phase 2: Service detection")
            services = await self._detect_services(scan_result.target, open_ports)
            
            # Phase 3: Vulnerability Detection
            scan_result.progress = 60
            logger.info(f"🔍 Phase 3: Vulnerability detection")
            vulnerabilities = await self._detect_vulnerabilities(scan_result.target, services)
            
            # Phase 4: Analysis & Reporting
            scan_result.progress = 90
            logger.info(f"🔍 Phase 4: Analysis and reporting")
            scan_result.vulnerabilities = vulnerabilities
            
            # Complete scan
            scan_result.status = "completed"
            scan_result.progress = 100
            scan_result.end_time = datetime.now()
            scan_result.duration = (scan_result.end_time - scan_result.start_time).total_seconds()
            
            # Move to history
            self.scan_history.append(scan_result)
            del self.active_scans[scan_id]
            
            logger.info(f"✅ Scan {scan_id} completed - Found {len(vulnerabilities)} vulnerabilities")
            
        except Exception as e:
            logger.error(f"❌ Scan {scan_id} failed: {str(e)}")
            scan_result.status = "failed"
            scan_result.end_time = datetime.now()

    async def _discover_ports(self, target: str) -> List[int]:
        """Discover open ports on target"""
        try:
            # Common ports to scan
            common_ports = [21, 22, 23, 25, 53, 80, 110, 111, 135, 139, 143, 443, 993, 995, 1723, 3306, 3389, 5432, 5900, 8080]
            open_ports = []
            
            for port in common_ports:
                try:
                    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    sock.settimeout(1)
                    result = sock.connect_ex((target, port))
                    if result == 0:
                        open_ports.append(port)
                    sock.close()
                except:
                    continue
                    
            logger.info(f"🔍 Found {len(open_ports)} open ports: {open_ports}")
            return open_ports
            
        except Exception as e:
            logger.error(f"❌ Port discovery failed: {str(e)}")
            return []

    async def _detect_services(self, target: str, ports: List[int]) -> Dict[int, str]:
        """Detect services running on open ports"""
        services = {}
        
        for port in ports:
            try:
                # Simple service detection based on common ports
                service_map = {
                    21: "FTP",
                    22: "SSH",
                    23: "Telnet",
                    25: "SMTP",
                    53: "DNS",
                    80: "HTTP",
                    110: "POP3",
                    135: "RPC",
                    139: "NetBIOS",
                    143: "IMAP",
                    443: "HTTPS",
                    993: "IMAPS",
                    995: "POP3S",
                    1723: "PPTP",
                    3306: "MySQL",
                    3389: "RDP",
                    5432: "PostgreSQL",
                    5900: "VNC",
                    8080: "HTTP-Alt"
                }
                
                services[port] = service_map.get(port, f"Unknown-{port}")
                
            except Exception as e:
                logger.error(f"❌ Service detection failed for port {port}: {str(e)}")
                
        logger.info(f"🔍 Detected {len(services)} services")
        return services

    async def _detect_vulnerabilities(self, target: str, services: Dict[int, str]) -> List[Vulnerability]:
        """Detect vulnerabilities in discovered services"""
        vulnerabilities = []
        
        for port, service in services.items():
            # Simulate vulnerability detection based on service
            if service == "FTP" and port == 21:
                vulnerabilities.append(Vulnerability(
                    id=str(uuid.uuid4()),
                    name="Anonymous FTP Access",
                    description="FTP server allows anonymous access",
                    severity=SeverityLevel.MEDIUM,
                    cvss_score=5.3,
                    cve_id=None,
                    affected_service=service,
                    port=port,
                    solution="Disable anonymous FTP access",
                    references=["https://owasp.org/www-community/vulnerabilities/Anonymous_FTP"],
                    discovered_at=datetime.now()
                ))
                
            elif service == "HTTP" and port == 80:
                vulnerabilities.append(Vulnerability(
                    id=str(uuid.uuid4()),
                    name="Unencrypted HTTP Service",
                    description="Web service running over unencrypted HTTP",
                    severity=SeverityLevel.LOW,
                    cvss_score=3.1,
                    cve_id=None,
                    affected_service=service,
                    port=port,
                    solution="Implement HTTPS with proper SSL/TLS configuration",
                    references=["https://owasp.org/www-community/controls/Transport_Layer_Security"],
                    discovered_at=datetime.now()
                ))
                
            elif service == "SSH" and port == 22:
                vulnerabilities.append(Vulnerability(
                    id=str(uuid.uuid4()),
                    name="SSH Service Detected",
                    description="SSH service is running and accessible",
                    severity=SeverityLevel.INFO,
                    cvss_score=0.0,
                    cve_id=None,
                    affected_service=service,
                    port=port,
                    solution="Ensure strong authentication and latest SSH version",
                    references=["https://www.ssh.com/academy/ssh/security"],
                    discovered_at=datetime.now()
                ))
                
        logger.info(f"🔍 Detected {len(vulnerabilities)} vulnerabilities")
        return vulnerabilities

    async def get_scan_results(self, scan_id: str) -> AsyncGenerator[Dict, None]:
        """Stream scan results as they become available"""
        while scan_id in self.active_scans:
            scan_result = self.active_scans[scan_id]
            yield {
                "scan_id": scan_id,
                "status": scan_result.status,
                "progress": scan_result.progress,
                "vulnerabilities_found": len(scan_result.vulnerabilities),
                "current_phase": self._get_current_phase(scan_result.progress)
            }
            await asyncio.sleep(1)
            
        # Send final results
        if scan_id in [s.scan_id for s in self.scan_history]:
            final_result = next(s for s in self.scan_history if s.scan_id == scan_id)
            yield {
                "scan_id": scan_id,
                "status": final_result.status,
                "progress": 100,
                "vulnerabilities": [self._vulnerability_to_dict(v) for v in final_result.vulnerabilities],
                "duration": final_result.duration,
                "completed": True
            }

    def _get_current_phase(self, progress: int) -> str:
        """Get current scan phase based on progress"""
        if progress < 20:
            return "Port Discovery"
        elif progress < 40:
            return "Service Detection"
        elif progress < 80:
            return "Vulnerability Detection"
        else:
            return "Analysis & Reporting"

    def _vulnerability_to_dict(self, vuln: Vulnerability) -> Dict:
        """Convert vulnerability to dictionary"""
        return {
            "id": vuln.id,
            "name": vuln.name,
            "description": vuln.description,
            "severity": vuln.severity.value,
            "cvss_score": vuln.cvss_score,
            "cve_id": vuln.cve_id,
            "affected_service": vuln.affected_service,
            "port": vuln.port,
            "solution": vuln.solution,
            "references": vuln.references,
            "discovered_at": vuln.discovered_at.isoformat()
        }

    async def start_continuous_scan(self):
        """Start continuous background scanning"""
        self._running = True
        self._continuous_scan_task = asyncio.create_task(self._continuous_scan_loop())
        logger.info("Started continuous vulnerability scanning")

    async def _continuous_scan_loop(self):
        """Continuous scanning background task"""
        while self._running:
            try:
                # Check for new targets or schedule periodic scans
                await asyncio.sleep(300)  # Check every 5 minutes
                
            except Exception as e:
                logger.error(f"❌ Continuous scan error: {str(e)}")
                await asyncio.sleep(60)

    async def stop_scan(self):
        """Stop continuous scanning"""
        self._running = False
        if self._continuous_scan_task:
            self._continuous_scan_task.cancel()
        logger.info("Stopped continuous vulnerability scanning")

    async def get_targets(self) -> List[Dict]:
        """Get list of scanned targets"""
        targets = set()
        for scan in self.scan_history:
            targets.add(scan.target)
        for scan in self.active_scans.values():
            targets.add(scan.target)
            
        return [{"target": target, "last_scanned": datetime.now().isoformat()} for target in targets]

    async def get_vulnerabilities(self) -> List[Dict]:
        """Get all discovered vulnerabilities"""
        all_vulns = []
        for scan in self.scan_history:
            for vuln in scan.vulnerabilities:
                vuln_dict = self._vulnerability_to_dict(vuln)
                vuln_dict["target"] = scan.target
                all_vulns.append(vuln_dict)
                
        return all_vulns
